use aiken/collection/list
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{LendingDatum, LendingRedeemer, Supply, Withdraw, Borrow, Repay, Liquidate, UpdateConfig}

/// {{ project_name }} lending pool validator.
/// - Users can supply liquidity to earn interest
/// - Users can withdraw their supplied liquidity
/// - Users can borrow against collateral with ratio enforcement
/// - Users can repay borrowed amounts
/// - Admin can liquidate undercollateralized positions
/// - Admin can update interest rate and collateral ratio
/// - Datum continuity enforced on every spend
/// - 2 ADA minimum floor maintained
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<LendingDatum>,
    redeemer: LendingRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let input_balance = lovelace_of(own_input.output.value)

    // Find continuing output at same address
    expect Some(cont_output) =
      list.find(self.outputs, fn(o) { o.address == own_address })
    let input_non_ada = without_lovelace(own_input.output.value)
    let output_non_ada = without_lovelace(cont_output.value)
    let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
    let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

    // Reference script protection
    expect cont_output.reference_script == None
    expect output_non_ada_assets == input_non_ada_assets

    // Validate continuing datum
    expect InlineDatum(raw) = cont_output.datum
    expect out_datum: LendingDatum = raw

    // Admin must remain the same
    expect out_datum.admin_pkh == datum.admin_pkh

    when redeemer is {
      Supply { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: total_supplied increases, rest unchanged
        expect out_datum.total_supplied == datum.total_supplied + amount
        expect out_datum.total_borrowed == datum.total_borrowed
        expect out_datum.interest_rate_bps == datum.interest_rate_bps
        expect out_datum.min_collateral_ratio_bps == datum.min_collateral_ratio_bps

        True
      }

      Withdraw { amount } -> {
        // Signer required for withdrawal
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Amount must be positive
        expect amount > 0

        // Maintain 2 ADA minimum floor
        expect input_balance >= amount + 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: total_supplied decreases, rest unchanged
        expect out_datum.total_supplied + amount == datum.total_supplied
        expect out_datum.total_borrowed == datum.total_borrowed
        expect out_datum.interest_rate_bps == datum.interest_rate_bps
        expect out_datum.min_collateral_ratio_bps == datum.min_collateral_ratio_bps

        True
      }

      Borrow { amount, collateral } -> {
        // Amount must be positive
        expect amount > 0
        expect collateral > 0
        expect amount <= 1_000_000_000_000
        expect collateral <= 1_000_000_000_000
        expect datum.min_collateral_ratio_bps > 0
        expect datum.min_collateral_ratio_bps <= 1_000_000

        // Conservative collateral guard.
        expect datum.min_collateral_ratio_bps >= 10_000
        expect collateral >= amount

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            assets.merge(
              own_input.output.value,
              assets.from_asset(ada_policy_id, ada_asset_name, collateral),
            ),
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: total_borrowed increases, rest unchanged
        expect out_datum.total_supplied == datum.total_supplied
        expect out_datum.total_borrowed == datum.total_borrowed + amount
        expect out_datum.interest_rate_bps == datum.interest_rate_bps
        expect out_datum.min_collateral_ratio_bps == datum.min_collateral_ratio_bps

        True
      }

      Repay { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: total_borrowed decreases, rest unchanged
        expect out_datum.total_supplied == datum.total_supplied
        expect out_datum.total_borrowed + amount == datum.total_borrowed
        expect out_datum.interest_rate_bps == datum.interest_rate_bps
        expect out_datum.min_collateral_ratio_bps == datum.min_collateral_ratio_bps

        True
      }

      Liquidate { amount } -> {
        // Admin must sign
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Amount must be positive
        expect amount > 0

        // Maintain 2 ADA minimum floor
        expect input_balance >= amount + 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: total_borrowed decreases, rest unchanged
        expect out_datum.total_supplied == datum.total_supplied
        expect out_datum.total_borrowed + amount == datum.total_borrowed
        expect out_datum.interest_rate_bps == datum.interest_rate_bps
        expect out_datum.min_collateral_ratio_bps == datum.min_collateral_ratio_bps

        True
      }

      UpdateConfig { new_rate_bps, new_ratio_bps } -> {
        // Admin must sign
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Rates must be valid
        expect new_rate_bps >= 0
        expect new_ratio_bps > 0

        // Only config params change
        expect out_datum.total_supplied == datum.total_supplied
        expect out_datum.total_borrowed == datum.total_borrowed
        expect out_datum.interest_rate_bps == new_rate_bps
        expect out_datum.min_collateral_ratio_bps == new_ratio_bps

        // Value must be preserved exactly.
        expect values_equal(cont_output.value, own_input.output.value)

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const admin_pkh: ByteArray = #"aa"
const user_pkh: ByteArray = #"bb"

fn pool_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> LendingDatum {
  LendingDatum {
    admin_pkh: admin_pkh,
    total_supplied: 10_000_000,
    total_borrowed: 0,
    interest_rate_bps: 500,
    min_collateral_ratio_bps: 15000,
  }
}

fn pool_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: pool_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

fn supply_output(new_lovelace: Int, new_supplied: Int) -> Output {
  Output {
    address: pool_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      LendingDatum {
        admin_pkh: admin_pkh,
        total_supplied: new_supplied,
        total_borrowed: 0,
        interest_rate_bps: 500,
        min_collateral_ratio_bps: 15000,
      },
    ),
    reference_script: None,
  }
}

fn borrow_output(new_lovelace: Int, new_borrowed: Int) -> Output {
  Output {
    address: pool_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      LendingDatum {
        admin_pkh: admin_pkh,
        total_supplied: 10_000_000,
        total_borrowed: new_borrowed,
        interest_rate_bps: 500,
        min_collateral_ratio_bps: 15000,
      },
    ),
    reference_script: None,
  }
}

// --- Supply Tests ---

test supply_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [supply_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Supply { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

// --- Withdraw Tests ---

test withdraw_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [pool_input()],
      outputs: [supply_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test withdraw_no_sig_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [user_pkh],
      inputs: [pool_input()],
      outputs: [supply_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

// --- Borrow Tests ---

test borrow_valid() {
  // Borrow 1M with 2M collateral (200% > 150% min ratio)
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [borrow_output(11_000_000, 1_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Borrow { amount: 1_000_000, collateral: 2_000_000 },
    test_oref(),
    tx,
  )
}

test borrow_undercollateralized_fails() fail {
  // Borrow 1M with 0.5M collateral (collateral < amount).
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [borrow_output(9_500_000, 1_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Borrow { amount: 1_000_000, collateral: 500_000 },
    test_oref(),
    tx,
  )
}

// --- Repay Tests ---

test repay_valid() {
  let borrowed_datum =
    LendingDatum {
      admin_pkh: admin_pkh,
      total_supplied: 10_000_000,
      total_borrowed: 5_000_000,
      interest_rate_bps: 500,
      min_collateral_ratio_bps: 15000,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [
        Input {
          output_reference: test_oref(),
          output: Output {
            address: pool_addr(),
            value: assets.from_lovelace(10_000_000),
            datum: InlineDatum(borrowed_datum),
            reference_script: None,
          },
        },
      ],
      outputs: [borrow_output(13_000_000, 2_000_000)],
    }
  {{ validator_name }}.spend(
    Some(borrowed_datum),
    Repay { amount: 3_000_000 },
    test_oref(),
    tx,
  )
}

// --- UpdateConfig Tests ---

test update_config_no_admin_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [user_pkh],
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: InlineDatum(
            LendingDatum {
              admin_pkh: admin_pkh,
              total_supplied: 10_000_000,
              total_borrowed: 0,
              interest_rate_bps: 700,
              min_collateral_ratio_bps: 12000,
            },
          ),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    UpdateConfig { new_rate_bps: 700, new_ratio_bps: 12000 },
    test_oref(),
    tx,
  )
}

// --- No Datum Test ---

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [supply_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    None,
    Supply { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}
