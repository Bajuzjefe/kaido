use aiken/collection/list
use cardano/address.{Address, Script, VerificationKey}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{GovernanceDatum, GovernanceRedeemer, Deposit, ExecuteProposal, UpdateAdmin}

/// {{ project_name }} DAO governance validator.
/// - Anyone can deposit funds into the treasury
/// - Admin can execute proposals (pay out to recipients)
/// - Admin can transfer control to a new admin
/// - Datum continuity enforced on every spend
/// - 2 ADA minimum floor maintained
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<GovernanceDatum>,
    redeemer: GovernanceRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let input_balance = lovelace_of(own_input.output.value)

    // Find continuing output at same address
    expect Some(cont_output) =
      list.find(self.outputs, fn(o) { o.address == own_address })
    let input_non_ada = without_lovelace(own_input.output.value)
    let output_non_ada = without_lovelace(cont_output.value)
    let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
    let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

    // Reference script protection
    expect cont_output.reference_script == None
    expect output_non_ada_assets == input_non_ada_assets

    // Validate continuing datum
    expect InlineDatum(raw) = cont_output.datum
    expect out_datum: GovernanceDatum = raw

    when redeemer is {
      Deposit { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum: admin and proposal_count unchanged, total_funds increases
        expect out_datum.admin_pkh == datum.admin_pkh
        expect out_datum.proposal_count == datum.proposal_count
        expect out_datum.total_funds == datum.total_funds + amount

        True
      }

      ExecuteProposal { proposal_id, recipient, payout_amount } -> {
        // Admin must sign
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Payout must be positive
        expect payout_amount > 0

        // Proposal ID must match expected next
        expect proposal_id == datum.proposal_count

        // Maintain 2 ADA minimum floor
        expect input_balance >= payout_amount + 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, payout_amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Verify recipient gets paid
        expect
          list.any(
            self.outputs,
            fn(o) {
              o.address.payment_credential == VerificationKey(recipient) && lovelace_of(
                o.value,
              ) >= payout_amount
            },
          )

        // Datum: admin unchanged, proposal_count increments, total_funds decreases
        expect out_datum.admin_pkh == datum.admin_pkh
        expect out_datum.proposal_count == datum.proposal_count + 1
        expect out_datum.total_funds + payout_amount == datum.total_funds

        True
      }

      UpdateAdmin { new_admin } -> {
        // Current admin must sign
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Only admin_pkh changes
        expect out_datum.admin_pkh == new_admin
        expect out_datum.proposal_count == datum.proposal_count
        expect out_datum.total_funds == datum.total_funds

        // Value must be preserved exactly.
        expect values_equal(cont_output.value, own_input.output.value)

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const admin_pkh: ByteArray = #"aa"
const new_admin_pkh: ByteArray = #"bb"
const recipient_pkh: ByteArray = #"cc"
const other_pkh: ByteArray = #"dd"

fn gov_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn recipient_addr() -> Address {
  Address { payment_credential: VerificationKey(recipient_pkh), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> GovernanceDatum {
  GovernanceDatum { admin_pkh: admin_pkh, proposal_count: 0, total_funds: 10_000_000 }
}

fn gov_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: gov_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

fn deposit_output(new_lovelace: Int, new_funds: Int) -> Output {
  Output {
    address: gov_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      GovernanceDatum {
        admin_pkh: admin_pkh,
        proposal_count: 0,
        total_funds: new_funds,
      },
    ),
    reference_script: None,
  }
}

fn proposal_output(new_lovelace: Int, new_count: Int, new_funds: Int) -> Output {
  Output {
    address: gov_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      GovernanceDatum {
        admin_pkh: admin_pkh,
        proposal_count: new_count,
        total_funds: new_funds,
      },
    ),
    reference_script: None,
  }
}

fn payout_output(lovelace: Int) -> Output {
  Output {
    address: recipient_addr(),
    value: assets.from_lovelace(lovelace),
    datum: InlineDatum(Void),
    reference_script: None,
  }
}

// --- Deposit Tests ---

test deposit_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [gov_input()],
      outputs: [deposit_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Deposit { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test deposit_zero_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [gov_input()],
      outputs: [deposit_output(10_000_000, 10_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Deposit { amount: 0 },
    test_oref(),
    tx,
  )
}

// --- ExecuteProposal Tests ---

test execute_proposal_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [gov_input()],
      outputs: [proposal_output(7_000_000, 1, 7_000_000), payout_output(3_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    ExecuteProposal { proposal_id: 0, recipient: recipient_pkh, payout_amount: 3_000_000 },
    test_oref(),
    tx,
  )
}

test execute_no_admin_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [other_pkh],
      inputs: [gov_input()],
      outputs: [proposal_output(7_000_000, 1, 7_000_000), payout_output(3_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    ExecuteProposal { proposal_id: 0, recipient: recipient_pkh, payout_amount: 3_000_000 },
    test_oref(),
    tx,
  )
}

test execute_below_floor_fails() fail {
  // Try to pay out 9M from 10M (leaves 1M, below 2 ADA floor)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [gov_input()],
      outputs: [proposal_output(1_000_000, 1, 1_000_000), payout_output(9_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    ExecuteProposal { proposal_id: 0, recipient: recipient_pkh, payout_amount: 9_000_000 },
    test_oref(),
    tx,
  )
}

// --- UpdateAdmin Tests ---

test update_admin_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [gov_input()],
      outputs: [
        Output {
          address: gov_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: InlineDatum(
            GovernanceDatum {
              admin_pkh: new_admin_pkh,
              proposal_count: 0,
              total_funds: 10_000_000,
            },
          ),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    UpdateAdmin { new_admin: new_admin_pkh },
    test_oref(),
    tx,
  )
}

// --- No Datum Test ---

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [gov_input()],
      outputs: [deposit_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    None,
    Deposit { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}
