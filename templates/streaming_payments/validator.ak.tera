use aiken/collection/list
use aiken/interval
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{StreamDatum, StreamRedeemer, Claim, Cancel, TopUp}

/// {{ project_name }} streaming payments validator.
/// - Recipient can claim available tranches after start_time
/// - Sender can cancel the stream and reclaim remaining funds
/// - Sender can top up the stream with additional funds
/// - Conditional continuity: Claim and TopUp require datum continuity, Cancel consumes UTxO
/// - 2 ADA minimum floor maintained on Claim
/// - Reference script injection protection
/// Generated by Kaido — Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<StreamDatum>,
    redeemer: StreamRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address

    when redeemer is {
      Claim { claim_amount } -> {
        // Recipient must sign
        expect list.has(self.extra_signatories, datum.recipient_pkh)

        // Claim amount must be positive
        expect claim_amount > 0

        // Stream must have started
        expect interval.is_entirely_after(self.validity_range, datum.start_time)

        // Cannot claim more than remaining
        expect datum.claimed_amount + claim_amount <= datum.total_amount

        // Find continuing output for datum continuity
        expect Some(cont_output) =
          list.find(self.outputs, fn(o) { o.address == own_address })
        let input_non_ada = without_lovelace(own_input.output.value)
        let output_non_ada = without_lovelace(cont_output.value)
        let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
        let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

        // Reference script protection
        expect cont_output.reference_script == None
        expect output_non_ada_assets == input_non_ada_assets

        // Validate continuing datum
        expect InlineDatum(raw) = cont_output.datum
        expect out_datum: StreamDatum = raw

        let output_balance = lovelace_of(cont_output.value)

        // All fields must persist except claimed_amount
        expect out_datum.sender_pkh == datum.sender_pkh
        expect out_datum.recipient_pkh == datum.recipient_pkh
        expect out_datum.total_amount == datum.total_amount
        expect out_datum.claimed_amount == datum.claimed_amount + claim_amount
        expect out_datum.start_time == datum.start_time
        expect out_datum.interval_ms == datum.interval_ms
        expect out_datum.tranche_amount == datum.tranche_amount

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, claim_amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Maintain 2 ADA minimum floor
        expect output_balance >= 2_000_000

        True
      }

      Cancel -> {
        // Sender must sign
        expect list.has(self.extra_signatories, datum.sender_pkh)

        // No continuity needed — UTxO is consumed fully
        True
      }

      TopUp { amount } -> {
        // Sender must sign
        expect list.has(self.extra_signatories, datum.sender_pkh)

        // Amount must be positive
        expect amount > 0

        // Find continuing output for datum continuity
        expect Some(cont_output) =
          list.find(self.outputs, fn(o) { o.address == own_address })
        let input_non_ada = without_lovelace(own_input.output.value)
        let output_non_ada = without_lovelace(cont_output.value)
        let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
        let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

        // Reference script protection
        expect cont_output.reference_script == None
        expect output_non_ada_assets == input_non_ada_assets

        // Validate continuing datum
        expect InlineDatum(raw) = cont_output.datum
        expect out_datum: StreamDatum = raw

        // All fields persist except total_amount increases
        expect out_datum.sender_pkh == datum.sender_pkh
        expect out_datum.recipient_pkh == datum.recipient_pkh
        expect out_datum.total_amount == datum.total_amount + amount
        expect out_datum.claimed_amount == datum.claimed_amount
        expect out_datum.start_time == datum.start_time
        expect out_datum.interval_ms == datum.interval_ms
        expect out_datum.tranche_amount == datum.tranche_amount

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const sender_pkh: ByteArray = #"aa"
const recipient_pkh: ByteArray = #"bb"
const other_pkh: ByteArray = #"cc"
const test_start: Int = 1_000_000

fn stream_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> StreamDatum {
  StreamDatum {
    sender_pkh: sender_pkh,
    recipient_pkh: recipient_pkh,
    total_amount: 10_000_000,
    claimed_amount: 0,
    start_time: test_start,
    interval_ms: 86_400_000,
    tranche_amount: 1_000_000,
  }
}

fn stream_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: stream_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

fn claim_output(new_lovelace: Int, new_claimed: Int) -> Output {
  Output {
    address: stream_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      StreamDatum {
        sender_pkh: sender_pkh,
        recipient_pkh: recipient_pkh,
        total_amount: 10_000_000,
        claimed_amount: new_claimed,
        start_time: test_start,
        interval_ms: 86_400_000,
        tranche_amount: 1_000_000,
      },
    ),
    reference_script: None,
  }
}

fn topup_output(new_lovelace: Int, new_total: Int) -> Output {
  Output {
    address: stream_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      StreamDatum {
        sender_pkh: sender_pkh,
        recipient_pkh: recipient_pkh,
        total_amount: new_total,
        claimed_amount: 0,
        start_time: test_start,
        interval_ms: 86_400_000,
        tranche_amount: 1_000_000,
      },
    ),
    reference_script: None,
  }
}

// --- Claim Tests ---

test claim_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [recipient_pkh],
      validity_range: interval.after(test_start + 1),
      inputs: [stream_input()],
      outputs: [claim_output(8_000_000, 2_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Claim { claim_amount: 2_000_000 },
    test_oref(),
    tx,
  )
}

test claim_before_start_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [recipient_pkh],
      validity_range: interval.before(test_start - 1),
      inputs: [stream_input()],
      outputs: [claim_output(8_000_000, 2_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Claim { claim_amount: 2_000_000 },
    test_oref(),
    tx,
  )
}

test claim_too_much_fails() fail {
  // Try to claim 15M when only 10M total
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [recipient_pkh],
      validity_range: interval.after(test_start + 1),
      inputs: [stream_input()],
      outputs: [claim_output(2_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Claim { claim_amount: 15_000_000 },
    test_oref(),
    tx,
  )
}

test claim_wrong_signer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [other_pkh],
      validity_range: interval.after(test_start + 1),
      inputs: [stream_input()],
      outputs: [claim_output(8_000_000, 2_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Claim { claim_amount: 2_000_000 },
    test_oref(),
    tx,
  )
}

// --- Cancel Tests ---

test cancel_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [sender_pkh],
      inputs: [stream_input()],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Cancel,
    test_oref(),
    tx,
  )
}

// --- TopUp Tests ---

test top_up_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [sender_pkh],
      inputs: [stream_input()],
      outputs: [topup_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    TopUp { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

// --- No Datum Test ---

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [recipient_pkh],
      validity_range: interval.after(test_start + 1),
      inputs: [stream_input()],
      outputs: [claim_output(8_000_000, 2_000_000)],
    }
  {{ validator_name }}.spend(
    None,
    Claim { claim_amount: 2_000_000 },
    test_oref(),
    tx,
  )
}
