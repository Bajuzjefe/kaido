// Transaction builder for {{ project_name }} oracle settlement.
// Generated by Kaido — Aiken Smart Contract Generator.

import type { BuildTxResult, UtxoRef, SettlementDatum } from "./types.js";
import { serializeSettlementRedeemer, serializeSettlementDatumInline } from "./serialization.js";

export interface IAnvilAdapter {
  getUtxos(address: string): Promise<string[]>;
  parseAddress(address: string): Promise<{ paymentKeyHash: string }>;
  scriptInteraction(payload: object): Promise<BuildTxResult>;
  submitTx(transaction: string, signatures: string[]): Promise<string>;
  timeToSlot(time: number): Promise<number>;
}

export interface PreloadedScript { type: "plutus"; blueprint: Record<string, unknown>; }

export class SettlementClient {
  constructor(
    private adapter: IAnvilAdapter,
    private validatorHash: string,
    private scriptAddress: string,
    private preloadedScript: PreloadedScript,
  ) {}

  /** Lock funds for settlement */
  async buildLock(senderAddress: string, datum: SettlementDatum, lovelace: bigint): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(senderAddress);
    return this.adapter.scriptInteraction({
      changeAddress: senderAddress, utxos,
      preloadedScripts: [this.preloadedScript], scriptInteractions: [],
      outputs: [{ address: this.scriptAddress, lovelace: Number(lovelace), datum: serializeSettlementDatumInline(datum, this.validatorHash) }],
    });
  }

  /** Oracle attests conditions met — seller receives payment */
  async buildSettle(oracleAddress: string, settlementUtxo: UtxoRef): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(oracleAddress);
    const { paymentKeyHash } = await this.adapter.parseAddress(oracleAddress);
    return this.adapter.scriptInteraction({
      changeAddress: oracleAddress, utxos,
      requiredSigners: [paymentKeyHash],
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [{ hash: this.validatorHash, purpose: "spend", outputRef: settlementUtxo, redeemer: serializeSettlementRedeemer({ tag: "Settle" }) }],
    });
  }

  /** Buyer reclaims after deadline */
  async buildReclaim(buyerAddress: string, settlementUtxo: UtxoRef): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(buyerAddress);
    const { paymentKeyHash } = await this.adapter.parseAddress(buyerAddress);
    return this.adapter.scriptInteraction({
      changeAddress: buyerAddress, utxos,
      requiredSigners: [paymentKeyHash],
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [{ hash: this.validatorHash, purpose: "spend", outputRef: settlementUtxo, redeemer: serializeSettlementRedeemer({ tag: "Reclaim" }) }],
    });
  }

  async submitTx(completeCbor: string, signatures: string[]): Promise<string> { return this.adapter.submitTx(completeCbor, signatures); }
}
