use aiken/collection/list
use aiken/interval
use cardano/address.{Address, Script, VerificationKey}
use cardano/assets
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{SettlementDatum, SettlementRedeemer, Settle, Reclaim}

/// {{ project_name }} oracle-gated settlement validator.
/// - Buyer locks funds at the script address with a SettlementDatum
/// - Oracle attests conditions are met → seller receives settlement amount
/// - If deadline passes without settlement → buyer can reclaim
/// - Oracle signature required for settlement (prevents oracle manipulation)
/// Generated by Kaido — Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<SettlementDatum>,
    redeemer: SettlementRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt
    expect datum.settlement_amount > 0

    // Correlate checks with the exact consumed script input.
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let script_input_count =
      list.foldl(
        self.inputs,
        0,
        fn(i, acc) {
          if i.output.address == own_address {
            acc + 1
          } else {
            acc
          }
        },
      )
    expect script_input_count == 1

    when redeemer is {
      Settle -> {
        // Oracle must sign to attest conditions are met
        expect list.has(self.extra_signatories, datum.oracle_pkh)

        // Must be before deadline
        expect interval.is_entirely_before(self.validity_range, datum.deadline)

        // Verify seller receives the settlement amount
        let seller_address =
          Address {
            payment_credential: VerificationKey(datum.seller_pkh),
            stake_credential: None,
          }

        expect Some(seller_output) =
          list.find(self.outputs, fn(o) { o.address == seller_address })

        expect
          seller_output.value == assets.from_lovelace(datum.settlement_amount)
        let input_non_ada = assets.without_lovelace(own_input.output.value)
        expect
          list.any(
            self.outputs,
            fn(output) { assets.without_lovelace(output.value) == input_non_ada },
          )
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }

      Reclaim -> {
        // Buyer must sign to reclaim
        expect list.has(self.extra_signatories, datum.buyer_pkh)

        // Must be after deadline
        expect interval.is_entirely_after(self.validity_range, datum.deadline)
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }
    }
  }

  else(_) {
    fail
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const buyer_pkh: ByteArray = #"aa"
const seller_pkh: ByteArray = #"bb"
const oracle_pkh: ByteArray = #"cc"
const deadline: Int = 1_000_000

fn seller_addr() -> Address {
  Address { payment_credential: VerificationKey(seller_pkh), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn test_datum() -> SettlementDatum {
  SettlementDatum {
    buyer_pkh: buyer_pkh,
    seller_pkh: seller_pkh,
    oracle_pkh: oracle_pkh,
    settlement_amount: 50_000_000,
    deadline: deadline,
  }
}

fn settlement_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn settlement_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: settlement_addr(),
      value: assets.from_lovelace(50_000_000),
      datum: InlineDatum(test_datum()),
      reference_script: None,
    },
  }
}

// --- Settle Tests ---

test settle_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [oracle_pkh],
      validity_range: interval.before(deadline - 1),
      inputs: [settlement_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(50_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Settle,
    test_oref(),
    tx,
  )
}

test settle_no_oracle_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [buyer_pkh],
      validity_range: interval.before(deadline - 1),
      inputs: [settlement_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(50_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Settle,
    test_oref(),
    tx,
  )
}

test settle_after_deadline_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [oracle_pkh],
      validity_range: interval.after(deadline + 1),
      inputs: [settlement_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(50_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Settle,
    test_oref(),
    tx,
  )
}

test settle_underpay_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [oracle_pkh],
      validity_range: interval.before(deadline - 1),
      inputs: [settlement_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Settle,
    test_oref(),
    tx,
  )
}

// --- Reclaim Tests ---

test reclaim_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [buyer_pkh],
      validity_range: interval.after(deadline + 1),
      inputs: [settlement_input()],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Reclaim,
    test_oref(),
    tx,
  )
}

test reclaim_before_deadline_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [buyer_pkh],
      validity_range: interval.before(deadline - 1),
      inputs: [settlement_input()],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Reclaim,
    test_oref(),
    tx,
  )
}

test reclaim_wrong_signer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [seller_pkh],
      validity_range: interval.after(deadline + 1),
      inputs: [settlement_input()],
    }
  {{ validator_name }}.spend(
    Some(test_datum()),
    Reclaim,
    test_oref(),
    tx,
  )
}

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [oracle_pkh],
      validity_range: interval.before(deadline - 1),
      inputs: [settlement_input()],
    }
  {{ validator_name }}.spend(
    None,
    Settle,
    test_oref(),
    tx,
  )
}
