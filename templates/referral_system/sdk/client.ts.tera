// Transaction builder for {{ project_name }} referral system.
// Generated by Kaido — Aiken Smart Contract Generator.
//
// Two validators:
//   - Mint validator (combined mint + config spend)
//   - Treasury validator (deposit/withdraw with datum continuity)

import type {
  BuildTxResult, UtxoRef, ConfigDatum, TreasuryDatum,
} from "./types.js";
import { CONFIG_TOKEN_NAME, TREASURY_TOKEN_NAME } from "./types.js";
import {
  serializeMintRedeemer, serializeConfigRedeemer, serializeTreasuryRedeemer,
  serializeConfigDatumInline, serializeTreasuryDatumInline,
} from "./serialization.js";

export interface IAnvilAdapter {
  getUtxos(address: string): Promise<string[]>;
  parseAddress(address: string): Promise<{ paymentKeyHash: string }>;
  scriptInteraction(payload: object): Promise<BuildTxResult>;
  submitTx(transaction: string, signatures: string[]): Promise<string>;
}

export interface PreloadedScript { type: "plutus"; blueprint: Record<string, unknown>; }

export class ReferralClient {
  constructor(
    private adapter: IAnvilAdapter,
    private policyId: string,
    private mintValidatorHash: string,
    private treasuryValidatorHash: string,
    private mintScript: PreloadedScript,
    private treasuryScript: PreloadedScript,
  ) {}

  /** Deploy: mint config + treasury tokens, create initial UTxOs */
  async buildDeploy(
    adminAddress: string,
    initialConfig: ConfigDatum,
    treasuryFundLovelace: bigint,
  ): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(adminAddress);
    const { paymentKeyHash: adminPkh } = await this.adapter.parseAddress(adminAddress);
    return this.adapter.scriptInteraction({
      changeAddress: adminAddress, utxos,
      requiredSigners: [adminPkh],
      preloadedScripts: [this.mintScript],
      scriptInteractions: [
        { hash: this.mintValidatorHash, purpose: "mint", redeemer: serializeMintRedeemer({ tag: "MintProjectTokens" }) },
      ],
      outputs: [
        {
          address: adminAddress, lovelace: 2_000_000,
          assets: [{ policyId: this.policyId, assetName: CONFIG_TOKEN_NAME, quantity: 1 }],
          datum: serializeConfigDatumInline(initialConfig, this.mintValidatorHash),
        },
        {
          address: adminAddress, lovelace: Number(treasuryFundLovelace),
          assets: [{ policyId: this.policyId, assetName: TREASURY_TOKEN_NAME, quantity: 1 }],
          datum: serializeTreasuryDatumInline({ totalDeposited: treasuryFundLovelace, totalWithdrawn: 0n }, this.treasuryValidatorHash),
        },
      ],
    });
  }

  /** Register a referral — referred user must sign (anti-sybil) */
  async buildRegisterReferral(referredAddress: string, referrerPkh: string): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(referredAddress);
    const { paymentKeyHash: referredPkh } = await this.adapter.parseAddress(referredAddress);
    return this.adapter.scriptInteraction({
      changeAddress: referredAddress, utxos,
      requiredSigners: [referredPkh],
      preloadedScripts: [this.mintScript],
      scriptInteractions: [
        { hash: this.mintValidatorHash, purpose: "mint", redeemer: serializeMintRedeemer({ tag: "MintReferralToken", referrerPkh, referredPkh }) },
      ],
    });
  }

  /** Fund the treasury — anyone can deposit */
  async buildFundTreasury(
    funderAddress: string,
    treasuryUtxo: UtxoRef,
    amount: bigint,
    currentDatum: TreasuryDatum,
  ): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(funderAddress);
    const updatedDatum: TreasuryDatum = {
      totalDeposited: currentDatum.totalDeposited + amount,
      totalWithdrawn: currentDatum.totalWithdrawn,
    };
    return this.adapter.scriptInteraction({
      changeAddress: funderAddress, utxos,
      preloadedScripts: [this.treasuryScript],
      scriptInteractions: [
        { hash: this.treasuryValidatorHash, purpose: "spend", outputRef: treasuryUtxo, redeemer: serializeTreasuryRedeemer({ tag: "Deposit", amount }) },
      ],
      outputs: [
        {
          address: funderAddress, lovelace: 2_000_000,
          assets: [{ policyId: this.policyId, assetName: TREASURY_TOKEN_NAME, quantity: 1 }],
          datum: serializeTreasuryDatumInline(updatedDatum, this.treasuryValidatorHash),
        },
      ],
    });
  }

  /** Withdraw from treasury — admin only, maintains 2 ADA floor */
  async buildWithdraw(
    adminAddress: string,
    treasuryUtxo: UtxoRef,
    amount: bigint,
    currentDatum: TreasuryDatum,
  ): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(adminAddress);
    const { paymentKeyHash: adminPkh } = await this.adapter.parseAddress(adminAddress);
    const updatedDatum: TreasuryDatum = {
      totalDeposited: currentDatum.totalDeposited,
      totalWithdrawn: currentDatum.totalWithdrawn + amount,
    };
    return this.adapter.scriptInteraction({
      changeAddress: adminAddress, utxos,
      requiredSigners: [adminPkh],
      preloadedScripts: [this.treasuryScript],
      scriptInteractions: [
        { hash: this.treasuryValidatorHash, purpose: "spend", outputRef: treasuryUtxo, redeemer: serializeTreasuryRedeemer({ tag: "Withdraw", amount }) },
      ],
      outputs: [
        {
          address: adminAddress, lovelace: 2_000_000,
          assets: [{ policyId: this.policyId, assetName: TREASURY_TOKEN_NAME, quantity: 1 }],
          datum: serializeTreasuryDatumInline(updatedDatum, this.treasuryValidatorHash),
        },
      ],
    });
  }

  /** Update config datum — admin only */
  async buildUpdateConfig(
    adminAddress: string,
    configUtxo: UtxoRef,
    newConfig: ConfigDatum,
  ): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(adminAddress);
    const { paymentKeyHash: adminPkh } = await this.adapter.parseAddress(adminAddress);
    return this.adapter.scriptInteraction({
      changeAddress: adminAddress, utxos,
      requiredSigners: [adminPkh],
      preloadedScripts: [this.mintScript],
      scriptInteractions: [
        { hash: this.mintValidatorHash, purpose: "spend", outputRef: configUtxo, redeemer: serializeConfigRedeemer({ tag: "UpdateConfig" }) },
      ],
      outputs: [
        {
          address: adminAddress, lovelace: 2_000_000,
          assets: [{ policyId: this.policyId, assetName: CONFIG_TOKEN_NAME, quantity: 1 }],
          datum: serializeConfigDatumInline(newConfig, this.mintValidatorHash),
        },
      ],
    });
  }

  /** Destroy project — admin burns config token */
  async buildDestroyProject(adminAddress: string, configUtxo: UtxoRef): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(adminAddress);
    const { paymentKeyHash: adminPkh } = await this.adapter.parseAddress(adminAddress);
    return this.adapter.scriptInteraction({
      changeAddress: adminAddress, utxos,
      requiredSigners: [adminPkh],
      preloadedScripts: [this.mintScript],
      scriptInteractions: [
        { hash: this.mintValidatorHash, purpose: "spend", outputRef: configUtxo, redeemer: serializeConfigRedeemer({ tag: "DestroyProject" }) },
        { hash: this.mintValidatorHash, purpose: "mint", redeemer: serializeMintRedeemer({ tag: "BurnToken" }) },
      ],
    });
  }

  async submitTx(completeCbor: string, signatures: string[]): Promise<string> {
    return this.adapter.submitTx(completeCbor, signatures);
  }
}
