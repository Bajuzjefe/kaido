/// Validation helpers for {{ project_name }} referral system.
/// Generated by Kaido â€” Aiken Smart Contract Generator.

use aiken/collection/list
use aiken/crypto
use aiken/primitive/bytearray
use cardano/address.{Address}
use cardano/assets.{has_nft}
use cardano/transaction.{Input, Output, OutputReference, Transaction}

/// Check that a key hash is in the transaction's extra_signatories.
pub fn signed_by(tx: Transaction, pkh: ByteArray) -> Bool {
  list.has(tx.extra_signatories, pkh)
}

/// Compute the deterministic referral token name: blake2b_256(referrer ++ referred).
pub fn referral_token_name(
  referrer_pkh: ByteArray,
  referred_pkh: ByteArray,
) -> ByteArray {
  crypto.blake2b_256(bytearray.concat(referrer_pkh, referred_pkh))
}

/// Find an output at the given address that holds the auth token.
pub fn ensure_output_has_token(
  outputs: List<Output>,
  address: Address,
  policy_id: ByteArray,
  token_name: ByteArray,
) -> Output {
  expect Some(output) =
    list.find(
      outputs,
      fn(o) {
        o.address == address && has_nft(o.value, policy_id, token_name)
      },
    )
  output
}

/// Find the input being spent by its output reference.
pub fn find_own_input(
  inputs: List<Input>,
  utxo: OutputReference,
) -> Input {
  expect Some(input) =
    list.find(inputs, fn(i) { i.output_reference == utxo })
  input
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

test referral_token_name_deterministic() {
  let a = #"aabbccdd"
  let b = #"11223344"
  referral_token_name(a, b) == referral_token_name(a, b)
}

test referral_token_name_different_for_different_pkhs() {
  let a = #"aabbccdd"
  let b = #"11223344"
  referral_token_name(a, b) != referral_token_name(b, a)
}

test referral_token_name_is_32_bytes() {
  let name = referral_token_name(#"aabb", #"ccdd")
  bytearray.length(name) == 32
}

test signed_by_present() {
  let tx =
    Transaction { ..transaction.placeholder, extra_signatories: [#"aa", #"bb"] }
  signed_by(tx, #"aa")
}

test signed_by_absent() {
  let tx =
    Transaction { ..transaction.placeholder, extra_signatories: [#"aa"] }
  !signed_by(tx, #"bb")
}
