use aiken/collection/dict
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets.{PolicyId}
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{
  BurnToken, ConfigDatum, ConfigRedeemer, DestroyProject, MintProjectTokens,
  MintReferralToken, MintRedeemer, UpdateConfig, config_token_name,
  treasury_token_name,
}
use {{ namespace }}/{{ module_name }}/validation

/// {{ project_name }} referral mint + config validator.
/// - MintProjectTokens: admin mints config + treasury tokens
/// - MintReferralToken: referred user mints proof-of-referral token (anti-sybil)
/// - BurnToken: anyone can burn (all quantities negative)
/// - UpdateConfig: admin updates config datum with continuity
/// - DestroyProject: admin burns config token
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }}_mint(admin_pkh: ByteArray) {
  mint(redeemer: MintRedeemer, policy_id: PolicyId, self: Transaction) {
    when redeemer is {
      MintProjectTokens -> {
        // Admin must sign
        expect validation.signed_by(self, admin_pkh)
        // Must mint exactly +1 config and +1 treasury token under this policy
        let expected =
          assets.from_asset(policy_id, config_token_name, 1)
            |> assets.add(policy_id, treasury_token_name, 1)
        expect values_equal(self.mint, expected)
        True
      }

      MintReferralToken { referrer_pkh, referred_pkh } -> {
        // Referred user must sign (anti-sybil)
        expect validation.signed_by(self, referred_pkh)
        // No self-referral
        expect referrer_pkh != referred_pkh
        // Compute expected token name
        let token_name =
          validation.referral_token_name(referrer_pkh, referred_pkh)
        // Must mint exactly +1 of this token under this policy
        let expected = assets.from_asset(policy_id, token_name, 1)
        expect values_equal(self.mint, expected)
        True
      }

      BurnToken -> {
        // All minted quantities under this policy must be negative
        let minted = assets.tokens(self.mint, policy_id)
        dict.foldl(minted, True, fn(_name, qty, acc) { acc && qty < 0 })
      }
    }
  }

  spend(
    datum: Option<ConfigDatum>,
    redeemer: ConfigRedeemer,
    utxo: OutputReference,
    self: Transaction,
  ) {
    expect Some(_config_datum) = datum
    let own_input = validation.find_own_input(self.inputs, utxo)
    let own_address = own_input.output.address
    expect Script(policy_id) = own_address.payment_credential

    when redeemer is {
      UpdateConfig -> {
        expect validation.signed_by(self, admin_pkh)
        // Config token must be returned to same address
        let output =
          validation.ensure_output_has_token(
            self.outputs,
            own_address,
            policy_id,
            config_token_name,
          )
        expect output.reference_script == None
        // Ensure output has a valid config datum
        expect InlineDatum(raw) = output.datum
        expect _new_config: ConfigDatum = raw
        True
      }
      DestroyProject -> {
        expect validation.signed_by(self, admin_pkh)
        // Config token must be burned
        let expected = assets.from_asset(policy_id, config_token_name, -1)
        expect values_equal(self.mint, expected)
        True
      }
    }
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Test helpers
// ---------------------------------------------------------------------------

const test_admin: ByteArray = #"aa"

const test_pid: ByteArray = #"dd"

fn test_script_address() -> Address {
  Address { payment_credential: Script(test_pid), stake_credential: None }
}

fn test_config() -> ConfigDatum {
  ConfigDatum { version: 1 }
}

// ---------------------------------------------------------------------------
// Mint: MintProjectTokens
// ---------------------------------------------------------------------------

test mint_project_tokens_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      mint: assets.from_asset(test_pid, config_token_name, 1)
        |> assets.add(test_pid, treasury_token_name, 1),
    }
  {{ validator_name }}_mint.mint(test_admin, MintProjectTokens, test_pid, tx)
}

test mint_project_tokens_wrong_signer() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [#"ff"],
      mint: assets.from_asset(test_pid, config_token_name, 1)
        |> assets.add(test_pid, treasury_token_name, 1),
    }
  {{ validator_name }}_mint.mint(test_admin, MintProjectTokens, test_pid, tx)
}

test mint_project_tokens_missing_treasury() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      mint: assets.from_asset(test_pid, config_token_name, 1),
    }
  {{ validator_name }}_mint.mint(test_admin, MintProjectTokens, test_pid, tx)
}

// ---------------------------------------------------------------------------
// Mint: MintReferralToken
// ---------------------------------------------------------------------------

test mint_referral_token_valid() {
  let referrer = #"bb"
  let referred = #"cc"
  let token_name = validation.referral_token_name(referrer, referred)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [referred],
      mint: assets.from_asset(test_pid, token_name, 1),
    }
  {{ validator_name }}_mint.mint(
    test_admin,
    MintReferralToken { referrer_pkh: referrer, referred_pkh: referred },
    test_pid,
    tx,
  )
}

test mint_referral_self_referral_fails() fail {
  let pkh = #"bb"
  let token_name = validation.referral_token_name(pkh, pkh)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [pkh],
      mint: assets.from_asset(test_pid, token_name, 1),
    }
  {{ validator_name }}_mint.mint(
    test_admin,
    MintReferralToken { referrer_pkh: pkh, referred_pkh: pkh },
    test_pid,
    tx,
  )
}

test mint_referral_wrong_signer_fails() fail {
  let referrer = #"bb"
  let referred = #"cc"
  let token_name = validation.referral_token_name(referrer, referred)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [referrer],
      mint: assets.from_asset(test_pid, token_name, 1),
    }
  {{ validator_name }}_mint.mint(
    test_admin,
    MintReferralToken { referrer_pkh: referrer, referred_pkh: referred },
    test_pid,
    tx,
  )
}

// ---------------------------------------------------------------------------
// Mint: BurnToken
// ---------------------------------------------------------------------------

test burn_token_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      mint: assets.from_asset(test_pid, config_token_name, -1),
    }
  {{ validator_name }}_mint.mint(test_admin, BurnToken, test_pid, tx)
}

test burn_token_positive_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      mint: assets.from_asset(test_pid, config_token_name, 1),
    }
  {{ validator_name }}_mint.mint(test_admin, BurnToken, test_pid, tx)
}

// ---------------------------------------------------------------------------
// Config Spend: UpdateConfig
// ---------------------------------------------------------------------------

test update_config_valid() {
  let own_utxo =
    OutputReference {
      transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
      output_index: 0,
    }
  let own_input =
    Input {
      output_reference: own_utxo,
      output: Output {
        address: test_script_address(),
        value: assets.from_lovelace(2_000_000)
          |> assets.add(test_pid, config_token_name, 1),
        datum: InlineDatum(test_config()),
        reference_script: None,
      },
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      inputs: [own_input],
      outputs: [
        Output {
          address: test_script_address(),
          value: assets.from_lovelace(2_000_000)
            |> assets.add(test_pid, config_token_name, 1),
          datum: InlineDatum(ConfigDatum { version: 2 }),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}_mint.spend(test_admin, Some(test_config()), UpdateConfig, own_utxo, tx)
}

test update_config_wrong_signer_fails() fail {
  let own_utxo =
    OutputReference {
      transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
      output_index: 0,
    }
  let own_input =
    Input {
      output_reference: own_utxo,
      output: Output {
        address: test_script_address(),
        value: assets.from_lovelace(2_000_000)
          |> assets.add(test_pid, config_token_name, 1),
        datum: InlineDatum(test_config()),
        reference_script: None,
      },
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [#"ff"],
      inputs: [own_input],
      outputs: [
        Output {
          address: test_script_address(),
          value: assets.from_lovelace(2_000_000)
            |> assets.add(test_pid, config_token_name, 1),
          datum: InlineDatum(test_config()),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}_mint.spend(test_admin, Some(test_config()), UpdateConfig, own_utxo, tx)
}

// ---------------------------------------------------------------------------
// Config Spend: DestroyProject
// ---------------------------------------------------------------------------

test destroy_project_valid() {
  let own_utxo =
    OutputReference {
      transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
      output_index: 0,
    }
  let own_input =
    Input {
      output_reference: own_utxo,
      output: Output {
        address: test_script_address(),
        value: assets.from_lovelace(2_000_000)
          |> assets.add(test_pid, config_token_name, 1),
        datum: InlineDatum(test_config()),
        reference_script: None,
      },
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      inputs: [own_input],
      mint: assets.from_asset(test_pid, config_token_name, -1),
    }
  {{ validator_name }}_mint.spend(
    test_admin,
    Some(test_config()),
    DestroyProject,
    own_utxo,
    tx,
  )
}

// ---------------------------------------------------------------------------
// Extra token attack prevention
// ---------------------------------------------------------------------------

test mint_referral_extra_token_fails() fail {
  let referrer = #"bb"
  let referred = #"cc"
  let token_name = validation.referral_token_name(referrer, referred)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [referred],
      mint: assets.from_asset(test_pid, token_name, 1)
        |> assets.add(test_pid, config_token_name, 1),
    }
  {{ validator_name }}_mint.mint(
    test_admin,
    MintReferralToken { referrer_pkh: referrer, referred_pkh: referred },
    test_pid,
    tx,
  )
}

test mint_project_extra_token_fails() fail {
  let referrer = #"bb"
  let referred = #"cc"
  let extra_name = validation.referral_token_name(referrer, referred)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      mint: assets.from_asset(test_pid, config_token_name, 1)
        |> assets.add(test_pid, treasury_token_name, 1)
        |> assets.add(test_pid, extra_name, 1),
    }
  {{ validator_name }}_mint.mint(test_admin, MintProjectTokens, test_pid, tx)
}
