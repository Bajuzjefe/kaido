use aiken/collection/list
use aiken/interval
use cardano/transaction
use cardano/transaction.{Transaction, OutputReference, InlineDatum{% if partial_claim %}, Input, Output{% endif %}}
use cardano/transaction/output_reference
{% if partial_claim %}use cardano/address.{Address, Script}
use cardano/assets{% endif %}

use {{ namespace }}/{{ module_name }}/types.{VestingDatum, VestingRedeemer, Claim{% if cancellable %}, Cancel{% endif %}}

/// {{ project_name }} vesting validator.
/// - Funds locked until `lock_until` timestamp
/// - Only beneficiary can claim after lock period
{% if cancellable %}/// - Owner can cancel and reclaim before lock period
{% endif %}{% if partial_claim %}/// - Supports partial claims with value preservation
{% endif %}/// Generated by Kaido — Aiken Smart Contract Generator.
validator {{ validator_name }}({% if cancellable %}owner_pkh: ByteArray{% endif %}) {
  spend(
    datum_opt: Option<VestingDatum>,
    redeemer: VestingRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    when redeemer is {
      Claim -> {
        // Beneficiary must sign
        expect list.has(self.extra_signatories, datum.beneficiary)

        // Lock period must have passed
        expect interval.is_entirely_after(self.validity_range, datum.lock_until)
{% if partial_claim %}

        // Find own input for value preservation
        expect Some(own_input) =
          list.find(self.inputs, fn(i) { i.output_reference == own_ref })
        let own_address = own_input.output.address

        // If there's a continuing output to our address, validate it
        let continuing_outputs =
          list.filter(
            self.outputs,
            fn(o) { o.address == own_address },
          )

        when continuing_outputs is {
          // Full claim — no continuing output required
          [] -> True
          // Partial claim — datum must be preserved
          [cont_output, ..] -> {
            expect InlineDatum(raw) = cont_output.datum
            expect cont_datum: VestingDatum = raw
            // Beneficiary cannot change
            expect cont_datum.beneficiary == datum.beneficiary
            // Lock time cannot change
            expect cont_datum.lock_until == datum.lock_until
            // Reference script protection
            expect cont_output.reference_script == None
            True
          }
        }
{% else %}
        True
{% endif %}
      }
{% if cancellable %}

      Cancel -> {
        // Only owner can cancel
        expect list.has(self.extra_signatories, owner_pkh)

        // Can only cancel BEFORE lock period
        expect interval.is_entirely_before(self.validity_range, datum.lock_until)

        True
      }
{% endif %}
    }
  }

  else(_) {
    fail
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const test_beneficiary: ByteArray = #"aabbccdd"
{% if cancellable %}
const test_owner: ByteArray = #"11223344"
{% endif %}
const test_lock_time: Int = 1_000_000

fn test_datum() -> VestingDatum {
  VestingDatum {
    beneficiary: test_beneficiary,
    lock_until: test_lock_time,
  }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}
{% if partial_claim %}
fn script_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn vesting_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: script_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(test_datum()),
      reference_script: None,
    },
  }
}
{% endif %}
test claim_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_beneficiary],
      validity_range: interval.after(test_lock_time + 1),
{% if partial_claim %}
      inputs: [vesting_input()],
{% endif %}
    }
  {{ validator_name }}.spend({% if cancellable %}test_owner, {% endif %}Some(test_datum()), Claim, test_oref(), tx)
}

test claim_before_lock_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_beneficiary],
      validity_range: interval.before(test_lock_time - 1),
    }
  {{ validator_name }}.spend({% if cancellable %}test_owner, {% endif %}Some(test_datum()), Claim, test_oref(), tx)
}

test claim_wrong_signer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [#"deadbeef"],
      validity_range: interval.after(test_lock_time + 1),
    }
  {{ validator_name }}.spend({% if cancellable %}test_owner, {% endif %}Some(test_datum()), Claim, test_oref(), tx)
}

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_beneficiary],
      validity_range: interval.after(test_lock_time + 1),
    }
  {{ validator_name }}.spend({% if cancellable %}test_owner, {% endif %}None, Claim, test_oref(), tx)
}
{% if cancellable %}

test cancel_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_owner],
      validity_range: interval.before(test_lock_time - 1),
    }
  {{ validator_name }}.spend(test_owner, Some(test_datum()), Cancel, test_oref(), tx)
}

test cancel_after_lock_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_owner],
      validity_range: interval.after(test_lock_time + 1),
    }
  {{ validator_name }}.spend(test_owner, Some(test_datum()), Cancel, test_oref(), tx)
}

test cancel_wrong_signer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [#"deadbeef"],
      validity_range: interval.before(test_lock_time - 1),
    }
  {{ validator_name }}.spend(test_owner, Some(test_datum()), Cancel, test_oref(), tx)
}
{% endif %}
