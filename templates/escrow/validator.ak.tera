use aiken/collection/list
use aiken/interval
use cardano/address
use cardano/address.{VerificationKey}
use cardano/assets
use cardano/transaction.{Transaction, OutputReference}
use cardano/transaction/output_reference

use {{ namespace }}/{{ module_name }}/types.{EscrowDatum, EscrowRedeemer, Complete, Reclaim, Cancel}

/// {{ project_name }} escrow validator.
/// - Buyer completes trade by paying seller
/// - Seller can reclaim after deadline
/// - Both parties can cancel by mutual agreement
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }}() {
  spend(
    datum_opt: Option<EscrowDatum>,
    redeemer: EscrowRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt
    expect datum.price > 0

    // Correlate checks with the exact consumed script input.
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let script_input_count =
      list.foldl(
        self.inputs,
        0,
        fn(i, acc) {
          if i.output.address == own_address {
            acc + 1
          } else {
            acc
          }
        },
      )
    // Prevent multi-input double satisfaction for this template.
    expect script_input_count == 1

    when redeemer is {
      Complete -> {
        // Buyer must sign
        expect list.has(self.extra_signatories, datum.buyer)

        // Must be before deadline
        expect interval.is_entirely_before(self.validity_range, datum.deadline)

        // Verify seller receives payment and script state is fully consumed.
        let seller_address =
          address.from_verification_key(datum.seller)
        expect Some(seller_output) =
          list.find(self.outputs, fn(output) { output.address == seller_address })
        expect seller_output.value == assets.from_lovelace(datum.price)
        let input_non_ada = assets.without_lovelace(own_input.output.value)
        expect
          list.any(
            self.outputs,
            fn(output) { assets.without_lovelace(output.value) == input_non_ada },
          )
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }

      Reclaim -> {
        // Seller must sign
        expect list.has(self.extra_signatories, datum.seller)

        // Deadline must have passed
        expect interval.is_entirely_after(self.validity_range, datum.deadline)
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }

      Cancel -> {
        // Both parties must sign for mutual cancellation
        expect list.has(self.extra_signatories, datum.seller)
        expect list.has(self.extra_signatories, datum.buyer)
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }
    }
  }

  else(_) {
    fail
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const test_seller: ByteArray = #"aabbccdd"
const test_buyer: ByteArray = #"11223344"
const test_price: Int = 10_000_000
const test_deadline: Int = 1_000_000

fn test_datum() -> EscrowDatum {
  EscrowDatum {
    seller: test_seller,
    buyer: test_buyer,
    price: test_price,
    deadline: test_deadline,
  }
}

fn test_oref() -> OutputReference {
  OutputReference { transaction_id: #"aa", output_index: 0 }
}

fn escrow_addr() -> address.Address {
  address.Address {
    payment_credential: address.Script(#"ee"),
    stake_credential: None,
  }
}

fn escrow_input() -> transaction.Input {
  transaction.Input {
    output_reference: test_oref(),
    output: transaction.Output {
      address: escrow_addr(),
      value: assets.from_lovelace(test_price),
      datum: transaction.InlineDatum(test_datum()),
      reference_script: None,
    },
  }
}

fn seller_output() -> transaction.Output {
  transaction.Output {
    address: address.from_verification_key(test_seller),
    value: assets.from_lovelace(test_price),
    datum: transaction.NoDatum,
    reference_script: None,
  }
}

test complete_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_buyer],
      validity_range: interval.before(test_deadline - 1),
      inputs: [escrow_input()],
      outputs: [seller_output()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Complete, test_oref(), tx)
}

test complete_no_buyer_sig_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [],
      validity_range: interval.before(test_deadline - 1),
      inputs: [escrow_input()],
      outputs: [seller_output()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Complete, test_oref(), tx)
}

test complete_no_payment_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_buyer],
      validity_range: interval.before(test_deadline - 1),
      inputs: [escrow_input()],
      outputs: [],
    }
  {{ validator_name }}.spend(Some(test_datum()), Complete, test_oref(), tx)
}

test reclaim_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_seller],
      validity_range: interval.after(test_deadline + 1),
      inputs: [escrow_input()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Reclaim, test_oref(), tx)
}

test reclaim_before_deadline_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_seller],
      validity_range: interval.before(test_deadline - 1),
      inputs: [escrow_input()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Reclaim, test_oref(), tx)
}

test cancel_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_seller, test_buyer],
      inputs: [escrow_input()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Cancel, test_oref(), tx)
}

test cancel_missing_buyer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_seller],
      inputs: [escrow_input()],
    }
  {{ validator_name }}.spend(Some(test_datum()), Cancel, test_oref(), tx)
}
