// Transaction builder for {{ project_name }} escrow contract.
// Generated by Kaido — Aiken Smart Contract Generator.

import type { BuildTxResult, UtxoRef, EscrowDatum } from "./types.js";
import { serializeEscrowRedeemer, serializeEscrowDatumInline } from "./serialization.js";

export interface IAnvilAdapter {
  getUtxos(address: string): Promise<string[]>;
  parseAddress(address: string): Promise<{ paymentKeyHash: string }>;
  scriptInteraction(payload: object): Promise<BuildTxResult>;
  submitTx(transaction: string, signatures: string[]): Promise<string>;
  timeToSlot(time: number): Promise<number>;
}

export interface PreloadedScript { type: "plutus"; blueprint: Record<string, unknown>; }

export class EscrowClient {
  constructor(
    private adapter: IAnvilAdapter,
    private validatorHash: string,
    private scriptAddress: string,
    private preloadedScript: PreloadedScript,
  ) {}

  /** Lock funds in escrow */
  async buildLock(senderAddress: string, datum: EscrowDatum, lovelace: bigint): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(senderAddress);
    return this.adapter.scriptInteraction({
      changeAddress: senderAddress, utxos,
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [],
      outputs: [{ address: this.scriptAddress, lovelace: Number(lovelace), datum: serializeEscrowDatumInline(datum, this.validatorHash) }],
    });
  }

  /** Buyer completes the trade — pays seller */
  async buildComplete(buyerAddress: string, escrowUtxo: UtxoRef, datum: EscrowDatum): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(buyerAddress);
    const { paymentKeyHash } = await this.adapter.parseAddress(buyerAddress);
    return this.adapter.scriptInteraction({
      changeAddress: buyerAddress, utxos,
      requiredSigners: [paymentKeyHash],
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [{ hash: this.validatorHash, purpose: "spend", outputRef: escrowUtxo, redeemer: serializeEscrowRedeemer({ tag: "Complete" }) }],
    });
  }

  /** Seller reclaims after deadline */
  async buildReclaim(sellerAddress: string, escrowUtxo: UtxoRef): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(sellerAddress);
    const { paymentKeyHash } = await this.adapter.parseAddress(sellerAddress);
    return this.adapter.scriptInteraction({
      changeAddress: sellerAddress, utxos,
      requiredSigners: [paymentKeyHash],
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [{ hash: this.validatorHash, purpose: "spend", outputRef: escrowUtxo, redeemer: serializeEscrowRedeemer({ tag: "Reclaim" }) }],
    });
  }

  /** Both parties cancel */
  async buildCancel(initiatorAddress: string, escrowUtxo: UtxoRef): Promise<BuildTxResult> {
    const utxos = await this.adapter.getUtxos(initiatorAddress);
    return this.adapter.scriptInteraction({
      changeAddress: initiatorAddress, utxos,
      preloadedScripts: [this.preloadedScript],
      scriptInteractions: [{ hash: this.validatorHash, purpose: "spend", outputRef: escrowUtxo, redeemer: serializeEscrowRedeemer({ tag: "Cancel" }) }],
    });
  }

  async submitTx(completeCbor: string, signatures: string[]): Promise<string> {
    return this.adapter.submitTx(completeCbor, signatures);
  }
}
