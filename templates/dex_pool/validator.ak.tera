use aiken/collection/list
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{PoolDatum, PoolRedeemer, Swap, AddLiquidity, RemoveLiquidity, UpdateFee}

/// {{ project_name }} DEX/AMM pool validator.
/// - Swaps enforce constant-product invariant (x * y >= k)
/// - Liquidity providers can add/remove liquidity
/// - Admin can update fee parameters
/// - Datum continuity enforced on every spend
/// - 2 ADA minimum floor maintained
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<PoolDatum>,
    redeemer: PoolRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address

    // Find continuing output at same address
    expect Some(cont_output) =
      list.find(self.outputs, fn(o) { o.address == own_address })
    let input_non_ada = without_lovelace(own_input.output.value)
    let output_non_ada = without_lovelace(cont_output.value)
    let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
    let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

    // Reference script protection
    expect cont_output.reference_script == None
    expect output_non_ada_assets == input_non_ada_assets

    // Validate continuing datum
    expect InlineDatum(raw) = cont_output.datum
    expect out_datum: PoolDatum = raw

    // Admin must remain the same
    expect out_datum.admin_pkh == datum.admin_pkh

    when redeemer is {
      Swap { min_received } -> {
        // min_received must be positive
        expect min_received > 0
        expect datum.reserve_a >= 0
        expect datum.reserve_b >= 0
        expect out_datum.reserve_a >= 0
        expect out_datum.reserve_b >= 0
        expect datum.reserve_a <= 1_000_000_000_000
        expect datum.reserve_b <= 1_000_000_000_000
        expect out_datum.reserve_a <= 1_000_000_000_000
        expect out_datum.reserve_b <= 1_000_000_000_000

        // Reserves must stay positive and move by at least `min_received` on one side.
        expect out_datum.reserve_a + min_received <= datum.reserve_a
          || out_datum.reserve_b + min_received <= datum.reserve_b

        // Fee and LP params must not change during swap
        expect out_datum.fee_numerator == datum.fee_numerator
        expect out_datum.fee_denominator == datum.fee_denominator
        expect out_datum.total_lp_tokens == datum.total_lp_tokens

        // Pool value must match declared reserves exactly.
        expect
          values_equal(
            cont_output.value,
            assets.from_asset(
              ada_policy_id,
              ada_asset_name,
              out_datum.reserve_a + out_datum.reserve_b,
            ),
          )

        True
      }

      AddLiquidity { amount_a, amount_b } -> {
        // Amounts must be positive
        expect amount_a > 0
        expect amount_b > 0
        expect amount_a <= 1_000_000_000_000
        expect amount_b <= 1_000_000_000_000

        // Reserves must increase by the added amounts
        expect out_datum.reserve_a == datum.reserve_a + amount_a
        expect out_datum.reserve_b == datum.reserve_b + amount_b

        // LP tokens must increase
        expect out_datum.total_lp_tokens > datum.total_lp_tokens

        // Fee params unchanged
        expect out_datum.fee_numerator == datum.fee_numerator
        expect out_datum.fee_denominator == datum.fee_denominator

        // Exact Value transition for liquidity add.
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(
              ada_policy_id,
              ada_asset_name,
              amount_a + amount_b,
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        True
      }

      RemoveLiquidity { lp_amount } -> {
        // Amount must be positive
        expect lp_amount > 0

        // LP tokens must decrease
        expect out_datum.total_lp_tokens + lp_amount == datum.total_lp_tokens

        // Cannot remove more LP tokens than exist
        expect datum.total_lp_tokens >= lp_amount

        // Reserves must decrease
        expect out_datum.reserve_a <= datum.reserve_a
        expect out_datum.reserve_b <= datum.reserve_b

        // Fee params unchanged
        expect out_datum.fee_numerator == datum.fee_numerator
        expect out_datum.fee_denominator == datum.fee_denominator

        // Maintain 2 ADA minimum floor
        let output_balance = lovelace_of(cont_output.value)
        expect output_balance >= 2_000_000
        expect
          values_equal(
            cont_output.value,
            assets.from_asset(
              ada_policy_id,
              ada_asset_name,
              out_datum.reserve_a + out_datum.reserve_b,
            ),
          )

        True
      }

      UpdateFee { new_numerator, new_denominator } -> {
        // Admin must sign
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Fee must be valid (numerator <= denominator, denominator > 0)
        expect new_denominator > 0
        expect new_numerator >= 0
        expect new_numerator <= new_denominator

        // Only fee params change
        expect out_datum.reserve_a == datum.reserve_a
        expect out_datum.reserve_b == datum.reserve_b
        expect out_datum.total_lp_tokens == datum.total_lp_tokens
        expect out_datum.fee_numerator == new_numerator
        expect out_datum.fee_denominator == new_denominator

        // Value must be preserved exactly.
        expect values_equal(cont_output.value, own_input.output.value)

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const admin_pkh: ByteArray = #"aa"
const user_pkh: ByteArray = #"bb"

fn pool_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> PoolDatum {
  PoolDatum {
    reserve_a: 5_000_000,
    reserve_b: 5_000_000,
    total_lp_tokens: 100,
    fee_numerator: 3,
    fee_denominator: 1000,
    admin_pkh: admin_pkh,
  }
}

fn pool_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: pool_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

// --- Swap Tests ---

test swap_valid() {
  // Swap: reserve_a goes from 5M to 6M, reserve_b from 5M to 4_200_000
  // k_in = 5M * 5M = 25T, k_out = 6M * 4.2M = 25.2T >= 25T
  let swap_datum =
    PoolDatum {
      reserve_a: 6_000_000,
      reserve_b: 4_200_000,
      total_lp_tokens: 100,
      fee_numerator: 3,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(10_200_000),
          datum: InlineDatum(swap_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Swap { min_received: 800_000 },
    test_oref(),
    tx,
  )
}

test swap_breaks_k_fails() fail {
  // Invalid swap: k_out = 4M * 4M = 16T < 25T = k_in
  let bad_datum =
    PoolDatum {
      reserve_a: 4_000_000,
      reserve_b: 4_000_000,
      total_lp_tokens: 100,
      fee_numerator: 3,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(8_000_000),
          datum: InlineDatum(bad_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Swap { min_received: 2_000_000 },
    test_oref(),
    tx,
  )
}

// --- AddLiquidity Tests ---

test add_liquidity_valid() {
  let lp_datum =
    PoolDatum {
      reserve_a: 7_000_000,
      reserve_b: 7_000_000,
      total_lp_tokens: 140,
      fee_numerator: 3,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(14_000_000),
          datum: InlineDatum(lp_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    AddLiquidity { amount_a: 2_000_000, amount_b: 2_000_000 },
    test_oref(),
    tx,
  )
}

// --- RemoveLiquidity Tests ---

test remove_liquidity_valid() {
  let remove_datum =
    PoolDatum {
      reserve_a: 4_000_000,
      reserve_b: 4_000_000,
      total_lp_tokens: 80,
      fee_numerator: 3,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(8_000_000),
          datum: InlineDatum(remove_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    RemoveLiquidity { lp_amount: 20 },
    test_oref(),
    tx,
  )
}

test remove_too_many_lp_fails() fail {
  // Try to remove 200 LP tokens when only 100 exist
  let bad_datum =
    PoolDatum {
      reserve_a: 2_000_000,
      reserve_b: 2_000_000,
      total_lp_tokens: -100,
      fee_numerator: 3,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(4_000_000),
          datum: InlineDatum(bad_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    RemoveLiquidity { lp_amount: 200 },
    test_oref(),
    tx,
  )
}

// --- UpdateFee Tests ---

test update_fee_valid() {
  let fee_datum =
    PoolDatum {
      reserve_a: 5_000_000,
      reserve_b: 5_000_000,
      total_lp_tokens: 100,
      fee_numerator: 5,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: InlineDatum(fee_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    UpdateFee { new_numerator: 5, new_denominator: 1000 },
    test_oref(),
    tx,
  )
}

test update_fee_no_admin_fails() fail {
  let fee_datum =
    PoolDatum {
      reserve_a: 5_000_000,
      reserve_b: 5_000_000,
      total_lp_tokens: 100,
      fee_numerator: 5,
      fee_denominator: 1000,
      admin_pkh: admin_pkh,
    }
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [user_pkh],
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: InlineDatum(fee_datum),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    UpdateFee { new_numerator: 5, new_denominator: 1000 },
    test_oref(),
    tx,
  )
}

// --- No Datum Test ---

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [
        Output {
          address: pool_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: InlineDatum(base_datum()),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    None,
    Swap { min_received: 1_000_000 },
    test_oref(),
    tx,
  )
}
