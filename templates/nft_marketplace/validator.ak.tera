use aiken/collection/list
use cardano/address.{Address, Script, VerificationKey}
use cardano/assets
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{ListingDatum, MarketplaceRedeemer, Buy, Delist}

/// {{ project_name }} NFT marketplace validator.
/// - Sellers list NFTs by sending them to the script address with a ListingDatum
/// - Buyers purchase by paying the seller's price to the seller's address
/// - Sellers can delist (cancel) at any time to reclaim their NFT
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<ListingDatum>,
    redeemer: MarketplaceRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt
    expect datum.price_lovelace > 0

    // Correlate checks with the exact consumed listing input.
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let script_input_count =
      list.foldl(
        self.inputs,
        0,
        fn(i, acc) {
          if i.output.address == own_address {
            acc + 1
          } else {
            acc
          }
        },
      )
    expect script_input_count == 1

    when redeemer is {
      Buy -> {
        // Verify seller receives payment
        let seller_address =
          Address {
            payment_credential: VerificationKey(datum.seller_pkh),
            stake_credential: None,
          }

        // Find output paying the seller
        expect Some(seller_output) =
          list.find(self.outputs, fn(o) { o.address == seller_address })

        // Seller must receive at least the listing price.
        expect seller_output.value == assets.from_lovelace(datum.price_lovelace)
        let input_non_ada = assets.without_lovelace(own_input.output.value)
        expect
          list.any(
            self.outputs,
            fn(output) { assets.without_lovelace(output.value) == input_non_ada },
          )
        // Listing must be fully consumed on buy.
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }

      Delist -> {
        // Only the seller can delist
        expect list.has(self.extra_signatories, datum.seller_pkh)
        // Listing must be fully consumed on delist.
        expect list.all(self.outputs, fn(output) { output.address != own_address })

        True
      }
    }
  }

  else(_) {
    fail
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const seller_pkh: ByteArray = #"aa"
const buyer_pkh: ByteArray = #"bb"
const test_policy: ByteArray = #"cc"
const test_asset: ByteArray = #"dd"

fn seller_addr() -> Address {
  Address { payment_credential: VerificationKey(seller_pkh), stake_credential: None }
}

fn buyer_addr() -> Address {
  Address { payment_credential: VerificationKey(buyer_pkh), stake_credential: None }
}

fn script_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn listing_datum() -> ListingDatum {
  ListingDatum {
    seller_pkh: seller_pkh,
    price_lovelace: 50_000_000,
    policy_id: test_policy,
    asset_name: test_asset,
  }
}

fn listing_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: script_addr(),
      value: assets.from_lovelace(2_000_000),
      datum: InlineDatum(listing_datum()),
      reference_script: None,
    },
  }
}

// --- Buy Tests ---

test buy_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [listing_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(50_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Buy,
    test_oref(),
    tx,
  )
}

test buy_overpay_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [listing_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(60_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Buy,
    test_oref(),
    tx,
  )
}

test buy_underpay_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [listing_input()],
      outputs: [
        Output {
          address: seller_addr(),
          value: assets.from_lovelace(10_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Buy,
    test_oref(),
    tx,
  )
}

test buy_wrong_recipient_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [listing_input()],
      outputs: [
        Output {
          address: buyer_addr(),
          value: assets.from_lovelace(50_000_000),
          datum: transaction.NoDatum,
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Buy,
    test_oref(),
    tx,
  )
}

// --- Delist Tests ---

test delist_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [seller_pkh],
      inputs: [listing_input()],
      outputs: [],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Delist,
    test_oref(),
    tx,
  )
}

test delist_wrong_signer_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [buyer_pkh],
      inputs: [listing_input()],
      outputs: [],
    }
  {{ validator_name }}.spend(
    Some(listing_datum()),
    Delist,
    test_oref(),
    tx,
  )
}

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [seller_pkh],
      inputs: [listing_input()],
      outputs: [],
    }
  {{ validator_name }}.spend(
    None,
    Delist,
    test_oref(),
    tx,
  )
}
