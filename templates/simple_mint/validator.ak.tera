use aiken/collection/dict
use aiken/collection/list
use cardano/assets
use cardano/assets.{PolicyId}
use cardano/transaction.{Transaction}
{% if time_lock %}
use aiken/interval
{% endif %}

use {{ namespace }}/{{ module_name }}/types.{MintRedeemer, Mint, Burn}

/// {{ token_name }} minting policy.
/// - Admin signature required for minting
/// - All quantities must be negative for burning
{% if time_lock %}/// - Time-locked: minting disabled after lock slot
{% endif %}/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }}(admin_pkh: ByteArray{% if time_lock %}, lock_after: Int{% endif %}) {
  mint(redeemer: MintRedeemer, policy_id: PolicyId, self: Transaction) {
    when redeemer is {
      Mint -> {
        // Admin must sign the transaction
        expect list.has(self.extra_signatories, admin_pkh)
{% if time_lock %}

        // Minting must happen before the lock time
        expect interval.is_entirely_before(self.validity_range, lock_after)
{% endif %}

        // At least one token must be minted with positive quantity
        let minted = assets.tokens(self.mint, policy_id)
        let all_positive =
          dict.foldl(minted, True, fn(_name, qty, acc) { acc && qty > 0 })
        expect all_positive

        // Verify expected token name is present
        let has_token =
          assets.quantity_of(self.mint, policy_id, "{{ asset_name }}") > 0
        expect has_token

        True
      }

      Burn -> {
        // All minted quantities under this policy must be negative
        let minted = assets.tokens(self.mint, policy_id)
        dict.foldl(minted, True, fn(_name, qty, acc) { acc && qty < 0 })
      }
    }
  }

  else(_) {
    fail
  }
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const test_admin: ByteArray = #"aabbccdd"
const test_policy: ByteArray = #"eeff0011"

test mint_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      mint: assets.from_asset(test_policy, "{{ asset_name }}", 1),
{% if time_lock %}
      validity_range: interval.before(100),
{% endif %}
    }
  {{ validator_name }}.mint(test_admin{% if time_lock %}, 200{% endif %}, Mint, test_policy, tx)
}

test mint_no_signature() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [],
      mint: assets.from_asset(test_policy, "{{ asset_name }}", 1),
{% if time_lock %}
      validity_range: interval.before(100),
{% endif %}
    }
  {{ validator_name }}.mint(test_admin{% if time_lock %}, 200{% endif %}, Mint, test_policy, tx)
}

test burn_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [],
      mint: assets.from_asset(test_policy, "{{ asset_name }}", -1),
    }
  {{ validator_name }}.mint(test_admin{% if time_lock %}, 200{% endif %}, Burn, test_policy, tx)
}

test burn_positive_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [],
      mint: assets.from_asset(test_policy, "{{ asset_name }}", 1),
    }
  {{ validator_name }}.mint(test_admin{% if time_lock %}, 200{% endif %}, Burn, test_policy, tx)
}
{% if time_lock %}

test mint_after_lock_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [test_admin],
      mint: assets.from_asset(test_policy, "{{ asset_name }}", 1),
      validity_range: interval.after(300),
    }
  {{ validator_name }}.mint(test_admin, 200, Mint, test_policy, tx)
}
{% endif %}
