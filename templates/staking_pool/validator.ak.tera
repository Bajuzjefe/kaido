use aiken/collection/list
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{PoolDatum, PoolRedeemer, Stake, Unstake, AddRewards}

/// {{ project_name }} staking pool validator.
/// - Users can stake ADA into the pool
/// - Users can unstake their ADA from the pool
/// - Admin can add rewards to the pool
/// - Datum continuity enforced on every spend
/// - 2 ADA minimum floor maintained
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }} {
  spend(
    datum_opt: Option<PoolDatum>,
    redeemer: PoolRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let input_balance = lovelace_of(own_input.output.value)

    // Find continuing output at same address
    expect Some(cont_output) =
      list.find(self.outputs, fn(o) { o.address == own_address })
    let input_non_ada = without_lovelace(own_input.output.value)
    let output_non_ada = without_lovelace(cont_output.value)
    let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
    let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

    // Reference script protection
    expect cont_output.reference_script == None
    expect output_non_ada_assets == input_non_ada_assets

    // Validate continuing datum
    expect InlineDatum(raw) = cont_output.datum
    expect out_datum: PoolDatum = raw

    // Admin must remain the same
    expect out_datum.admin_pkh == datum.admin_pkh

    when redeemer is {
      Stake { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum must reflect the stake
        expect out_datum.total_staked == datum.total_staked + amount
        expect out_datum.total_rewards_distributed == datum.total_rewards_distributed

        True
      }

      Unstake { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Maintain 2 ADA minimum floor
        expect input_balance >= amount + 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum must reflect the unstake
        expect out_datum.total_staked + amount == datum.total_staked

        // Cannot unstake more than total staked
        expect datum.total_staked >= amount
        expect out_datum.total_rewards_distributed == datum.total_rewards_distributed

        True
      }

      AddRewards { amount } -> {
        // Only admin can add rewards
        expect list.has(self.extra_signatories, datum.admin_pkh)

        // Amount must be positive
        expect amount > 0

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum must reflect the added rewards
        expect out_datum.total_staked == datum.total_staked
        expect out_datum.total_rewards_distributed == datum.total_rewards_distributed + amount

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const admin_pkh: ByteArray = #"aa"
const user_pkh: ByteArray = #"bb"

fn pool_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> PoolDatum {
  PoolDatum { admin_pkh: admin_pkh, total_staked: 10_000_000, total_rewards_distributed: 0 }
}

fn pool_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: pool_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

fn stake_output(new_lovelace: Int, new_staked: Int) -> Output {
  Output {
    address: pool_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      PoolDatum { admin_pkh: admin_pkh, total_staked: new_staked, total_rewards_distributed: 0 },
    ),
    reference_script: None,
  }
}

fn unstake_output(new_lovelace: Int, new_staked: Int) -> Output {
  Output {
    address: pool_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      PoolDatum { admin_pkh: admin_pkh, total_staked: new_staked, total_rewards_distributed: 0 },
    ),
    reference_script: None,
  }
}

fn rewards_output(new_lovelace: Int, new_rewards: Int) -> Output {
  Output {
    address: pool_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      PoolDatum {
        admin_pkh: admin_pkh,
        total_staked: 10_000_000,
        total_rewards_distributed: new_rewards,
      },
    ),
    reference_script: None,
  }
}

// --- Stake Tests ---

test stake_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [stake_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Stake { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test stake_zero_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [stake_output(10_000_000, 10_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Stake { amount: 0 },
    test_oref(),
    tx,
  )
}

// --- Unstake Tests ---

test unstake_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [unstake_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Unstake { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test unstake_below_floor_fails() fail {
  // Try to unstake 9M from 10M (leaves 1M, below 2 ADA floor)
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [unstake_output(1_000_000, 1_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Unstake { amount: 9_000_000 },
    test_oref(),
    tx,
  )
}

test unstake_more_than_staked_fails() fail {
  // Try to unstake 11M when only 10M staked
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [unstake_output(2_000_000, 0)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    Unstake { amount: 11_000_000 },
    test_oref(),
    tx,
  )
}

// --- AddRewards Tests ---

test add_rewards_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [admin_pkh],
      inputs: [pool_input()],
      outputs: [rewards_output(15_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    AddRewards { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test add_rewards_no_admin_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [user_pkh],
      inputs: [pool_input()],
      outputs: [rewards_output(15_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    Some(base_datum()),
    AddRewards { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [pool_input()],
      outputs: [stake_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    None,
    Stake { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}
