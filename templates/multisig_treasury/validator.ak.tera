use aiken/collection/list
use cardano/address.{Address, Script}
use cardano/assets
use cardano/assets/strategy
use cardano/assets.{ada_asset_name, ada_policy_id, lovelace_of, without_lovelace}
use cardano/transaction.{InlineDatum, Input, Output, OutputReference, Transaction}

use {{ namespace }}/{{ module_name }}/types.{TreasuryDatum, TreasuryRedeemer, Deposit, Withdraw}

/// {{ project_name }} multisig treasury validator.
/// - Anyone can deposit funds
/// - Withdrawals require threshold-of-N authorized signers
/// - 2 ADA minimum floor maintained at all times
/// - Datum continuity enforced on every spend
/// - Reference script injection protection
/// Generated by Kaido â€” Aiken Smart Contract Generator.
validator {{ validator_name }}(signers: List<ByteArray>, threshold: Int) {
  spend(
    datum_opt: Option<TreasuryDatum>,
    redeemer: TreasuryRedeemer,
    own_ref: OutputReference,
    self: Transaction,
  ) {
    // Safe datum deconstruction
    expect Some(datum) = datum_opt

    // Find own input to get address and current value
    expect Some(own_input) =
      list.find(self.inputs, fn(i) { i.output_reference == own_ref })
    let own_address = own_input.output.address
    let input_balance = lovelace_of(own_input.output.value)

    // Find continuing output at same address
    expect Some(cont_output) =
      list.find(self.outputs, fn(o) { o.address == own_address })
    let input_non_ada = without_lovelace(own_input.output.value)
    let output_non_ada = without_lovelace(cont_output.value)
    let input_non_ada_assets = assets.flatten_with(input_non_ada, strategy.triple())
    let output_non_ada_assets = assets.flatten_with(output_non_ada, strategy.triple())

    // Reference script protection
    expect cont_output.reference_script == None
    expect output_non_ada_assets == input_non_ada_assets

    // Validate continuing datum
    expect InlineDatum(raw) = cont_output.datum
    expect out_datum: TreasuryDatum = raw

    when redeemer is {
      Deposit { amount } -> {
        // Amount must be positive
        expect amount >= 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.from_asset(ada_policy_id, ada_asset_name, amount),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum must reflect the deposit
        expect out_datum.total_deposited == datum.total_deposited + amount
        expect out_datum.total_withdrawn == datum.total_withdrawn

        True
      }

      Withdraw { amount } -> {
        // Amount must be positive
        expect amount > 0

        // Check threshold signatures from authorized signers
        let sig_count =
          list.foldl(
            signers,
            0,
            fn(signer, acc) {
              if list.has(self.extra_signatories, signer) {
                acc + 1
              } else {
                acc
              }
            },
          )
        expect sig_count >= threshold

        // Maintain 2 ADA minimum floor
        expect input_balance >= amount + 2_000_000

        // Exact Value transition (including all native assets).
        let expected_output_value =
          assets.merge(
            own_input.output.value,
            assets.negate(
              assets.from_asset(ada_policy_id, ada_asset_name, amount),
            ),
          )
        expect values_equal(cont_output.value, expected_output_value)

        // Datum must reflect the withdrawal
        expect out_datum.total_deposited == datum.total_deposited
        expect out_datum.total_withdrawn == datum.total_withdrawn + amount

        True
      }
    }
  }

  else(_) {
    fail
  }
}

fn values_equal(left: assets.Value, right: assets.Value) -> Bool {
  assets.merge(left, assets.negate(right)) == assets.zero
}

// ---------------------------------------------------------------------------
// Tests
// ---------------------------------------------------------------------------

const signer_a: ByteArray = #"aa"
const signer_b: ByteArray = #"bb"
const signer_c: ByteArray = #"cc"
const test_signers: List<ByteArray> = [signer_a, signer_b, signer_c]
const test_threshold: Int = 2

fn treasury_addr() -> Address {
  Address { payment_credential: Script(#"ee"), stake_credential: None }
}

fn test_oref() -> OutputReference {
  OutputReference {
    transaction_id: #"0000000000000000000000000000000000000000000000000000000000000001",
    output_index: 0,
  }
}

fn base_datum() -> TreasuryDatum {
  TreasuryDatum { total_deposited: 10_000_000, total_withdrawn: 0 }
}

fn treasury_input() -> Input {
  Input {
    output_reference: test_oref(),
    output: Output {
      address: treasury_addr(),
      value: assets.from_lovelace(10_000_000),
      datum: InlineDatum(base_datum()),
      reference_script: None,
    },
  }
}

fn deposit_output(new_lovelace: Int, new_deposited: Int) -> Output {
  Output {
    address: treasury_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      TreasuryDatum { total_deposited: new_deposited, total_withdrawn: 0 },
    ),
    reference_script: None,
  }
}

fn withdraw_output(new_lovelace: Int, new_withdrawn: Int) -> Output {
  Output {
    address: treasury_addr(),
    value: assets.from_lovelace(new_lovelace),
    datum: InlineDatum(
      TreasuryDatum { total_deposited: 10_000_000, total_withdrawn: new_withdrawn },
    ),
    reference_script: None,
  }
}

// --- Deposit Tests ---

test deposit_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [treasury_input()],
      outputs: [deposit_output(15_000_000, 15_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Deposit { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test deposit_zero_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      inputs: [treasury_input()],
      outputs: [deposit_output(10_000_000, 10_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Deposit { amount: 0 },
    test_oref(),
    tx,
  )
}

// --- Withdraw Tests ---

test withdraw_valid() {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a, signer_b],
      inputs: [treasury_input()],
      outputs: [withdraw_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test withdraw_insufficient_sigs_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a],
      inputs: [treasury_input()],
      outputs: [withdraw_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test withdraw_below_floor_fails() fail {
  // Try to withdraw 9M from 10M (leaves 1M, below 2 ADA floor)
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a, signer_b],
      inputs: [treasury_input()],
      outputs: [withdraw_output(1_000_000, 9_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Withdraw { amount: 9_000_000 },
    test_oref(),
    tx,
  )
}

test withdraw_bad_datum_fails() fail {
  // Correct withdrawal but datum doesn't update total_withdrawn
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a, signer_b],
      inputs: [treasury_input()],
      outputs: [
        Output {
          address: treasury_addr(),
          value: assets.from_lovelace(5_000_000),
          datum: InlineDatum(base_datum()),
          reference_script: None,
        },
      ],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test withdraw_reference_script_injection_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a, signer_b],
      inputs: [treasury_input()],
      outputs: [
        Output {
          address: treasury_addr(),
          value: assets.from_lovelace(5_000_000),
          datum: InlineDatum(
            TreasuryDatum { total_deposited: 10_000_000, total_withdrawn: 5_000_000 },
          ),
          reference_script: Some(#"deadbeef"),
        },
      ],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    Some(base_datum()),
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}

test no_datum_fails() fail {
  let tx =
    Transaction {
      ..transaction.placeholder,
      extra_signatories: [signer_a, signer_b],
      inputs: [treasury_input()],
      outputs: [withdraw_output(5_000_000, 5_000_000)],
    }
  {{ validator_name }}.spend(
    test_signers,
    test_threshold,
    None,
    Withdraw { amount: 5_000_000 },
    test_oref(),
    tx,
  )
}
